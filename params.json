{"name":"Minx","body":"Massive and pervasive concurrency with Minx!\r\n\r\nMinx uses the powerful concurrency primitives outlined by Tony Hoare in his\r\nfamous book \"Communicating Sequential Processes\". This library was written\r\nas part of [my bachelor thesis](http://cl.ly/2E2s471i122S3I1s3W30).\r\n\r\n\r\nUsage\r\n-----\r\n\r\nMinx lets you easily create concurrent programs using the notion of *processes*\r\nand *channels*.\r\n\r\n```ruby\r\n# Very contrived example...\r\nchan = Minx.channel\r\n\r\nMinx.spawn { chan.write(\"Hello, World!\") }\r\nMinx.spawn { puts chan.read }\r\n```\r\n\r\nThese primitives, although simple, are incredibly powerful when composing highly\r\nconcurrent applications. When reading from or writing to a channel, a process\r\nyields execution -- and thus blocks until another process also participates in\r\nthe communication. An example of when this would be useful is a simple network\r\nserver:\r\n\r\n```ruby\r\n# Create a channel for the incoming requests.\r\nrequests = Minx.channel\r\n\r\n# Spawn 10 workers.\r\n10.times do\r\n  Minx.spawn do\r\n    requests.each {|request| handle_request(request) }\r\n  end\r\nend\r\n```\r\n\r\nIn the future, evented IO will be implemented, allowing for highly\r\nperformant network and file applications.\r\n\r\n\r\nDocumentation\r\n-------------\r\n\r\nSee [the full documentation](http://rubydoc.info/github/dasch/minx/master/frames).\r\n\r\n\r\nCopyright\r\n---------\r\n\r\nCopyright (c) 2010 Daniel Schierbeck (@dasch).","tagline":"A library for creating massively concurrent applications in Ruby","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}